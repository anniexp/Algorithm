using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

/// <summary>
/// Напишете компютърна програма, извеждаща следната редица: 1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1, 5, 1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1, 6, 1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1, 5, 1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1,...... (https://oeis.org/A001511).

///Рекурентното дефиниране на редицата е следното: G(1) = { 1}
///G(k) = { G(k - 1), k, G(k - 1)}, за k > 1.

///Програмата да съдържа два метода (рекурсивен и нерекурсивен), генериращи и извеждащи въпросната редица за произволно естествено число k. Да се има предвид, че броят на елементите на G(k) e 2 ^ k - 1(т.е., за големи стойности на k имплементация, съхраняваща редицата в паметта, ще предизвиква препълване).
/// </summary>
namespace SetOfGray
{
    class Program
    {
        /// <summary>
        /// Recursive construction of the sequence,generated by the Ruler Function
        /// </summary>
        /// <param name="k">paramether of the function G</param>
        /// <returns>set of numbers of kind  G(k) = {G(k-1), k, G(k-1)}, for k > 1</returns>
        public static string  SetOfTheRulerFunctionRecursive(int k)
        {
            
            if (k <= 0)
                return null ;           

            if ( k == 1)                            
                 return "1";

            //we convert int k to string because the method is supposed to return a string 
            return (SetOfTheRulerFunctionRecursive(k - 1) + " , " + Convert.ToString(k) + " , " + SetOfTheRulerFunctionRecursive(k - 1));

            
        }

        public static void SetOfGrayNonRecursive(int k)
        {
            

            // i - number of codes, j - number of
            //generated from the loop codes
            int i;
            int j;
            if (k <= 0)
                return;
            //the generated codes will be stored in codes
            List<string> codes = new List<string>();

            for (k = 0; k <= 9; k++)
            {
                codes.Add(Convert.ToString(k));
            }


            // Enter the prviously generated codes again in code[] in reverse
            // order. Now arr[] has double number of codes. 
            for (i = 2; i < (1 << k); i = i << 1)
            {
                for (j = i - 1; j >= 0; j--)
                {
                    codes.Add(codes[j]);
                }
                // append 0 to the first half   
                for (j = 0; j < i; j++)
                {
                    codes[j] = "0" + codes[j];
                }
                // append 1 to the second half   
                for (j = i; j < 2 * i; j++)
                {
                    codes[j] = "1" + codes[j];
                }
            }
            // print contents of codes[]   
            for (i = 0; i < codes.Count; i++)
            {
                Console.WriteLine(codes[i]);
            }



        }

        /// <summary>
        /// Generating Gray Code by iteration
        /// </summary>
        /// <param name="k"></param>
        ///
        public static void GrayCodeNonRecursive(int k)
        {
            // i - number of codes, j - number of
            //generated from the loop codes
            int i;
            int j;
            if (k <= 0)
                return;
            //the generated codes will be stored in arr
            List<string> codes = new List<string>();
            codes.Add("0");
            codes.Add("1");



            // Enter the prviously generated codes again in code[] in reverse
            // order. Now arr[] has double number of codes. 
            for (i = 2; i < (1 << k); i = i << 1)
            {
                for (j = i - 1; j >= 0; j--)
                {
                    codes.Add(codes[j]);
                }
                // append 0 to the first half   
                for (j = 0; j < i; j++)
                {
                    codes[j] = "0" + codes[j];
                }
                // append 1 to the second half   
                for (j = i; j < 2 * i; j++)
                {
                    codes[j] = "1" + codes[j];
                }
            }
            // print contents of codes[]   
            for (i = 0; i < codes.Count; i++)
            {
                Console.WriteLine(codes[i]);
            }


        }
        public static void SetOfGrayNonRecursiveFindElement()
        {
            int m, n,k;
            k = 10;
            n = 5;
            k = n + k;
            if (n > k)
                m = n * k + n;
            else
                m = (n - k) * 2;
            Console.WriteLine(m);
        }

        /// <summary>
        /// Iterative construction of the sequence,generated by the Ruler Function
        /// </summary>
        /// <param name="k">paramether of the function G</param>
        public static void SetOfTheRulerFunctionNonRecursive(int k)
        {
            //s - length of array,
            //j -  index of el in the set,
            // i - value of index of el;
            int s = Convert.ToInt32(Math.Pow(2, k) - 1);
            int[] set = new int[s];

            //purvonachalno obhojdame cikul s vujmojnite stoinosti na 
            // elementite na redicata, koyato shte poluchim. Vseki
            //element prisvoyava edna ot tezi stoinisti, taka che 
            //vurtim vtori cikul s tyah. Veche na vsyaka poziciya koyato e 
            //kratna na nyakoya ot vuzmojnite stoinosti prisvoyavame 
            // stoinostta, kakto sa po uslovie chlenovete na reda.
            
            int i;
                for ( i = 1; i <=k; i++)
                {                                       

                     for (int j = 0; j<= set.Length-1;j++)
                     {
                   
                            if ((j + 1) % (Math.Pow(2, (i - 1))) == 0)
                            {
                                  set[j] = i;
                            }
                     }                           

                }
            
             foreach (Object obj in set)
                 Console.Write("{0}   ", obj);
             Console.WriteLine();
 
        }
       

        static void Main(string[] args)
       {

           // Console.WriteLine(GrayCodeRecursive(k-1) + " , " + k + " , " + GrayCodeRecursive(k - 1));*/
             Console.WriteLine(SetOfTheRulerFunctionRecursive(4));
            //  SetOfGrayNonRecursive(3);
            SetOfTheRulerFunctionNonRecursive(4);

        }
    }
}
